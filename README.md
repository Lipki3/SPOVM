Л.р. 1: Знакомство с Linux (Unix) и средой программирования. 
Задание: Освоить эффективную работу с файлами в оболочке и mc. 

Л.р. 2: POSIX-совместимая файловая система.
Задание: Разработать программу dirwalk, сканирующую файловую систему и выводящую в stdout информацию в соответствии с опциями программы. Формат вывода аналогичен формату вывода утилиты find. 

Л.р. 3: Понятие процессов.
Задание: Создаются две программы ‒ parent и child.
Перед запуском программы parent в окружении создается переменная среды
CHILD_PATH с именем каталога, где находится программа child.
Родительский процесс (программа parent) после запуска получает переменные
среды, сортирует их в LC_COLLATE=C и выводит в stdout. После этого входит в цикл обработки нажатий клавиатуры.
Символ «+» порождает дочерний процесс, используя fork() и execve(), запускает
очередной экземпляр программы child., используя информацию о каталоге из окружения, которую получает, используя функцию getenv(). Имя программы (argv[0]) устанавливается как child_XX, где XX порядковый номер от 00 до 99. Номер инкрементиру ‒ -
ется родителем.
Символ «*» порождает дочерний процесс аналогично предыдущему случаю, однако информацию о его расположении получает, сканируя массив параметров среды,
переданный в третьем параметре функции main().
Символ «&» порождает дочерний процесс аналогично предыдущему случаю, однако информацию о его расположении получает, сканируя массив параметров среды,
указанный в переданный во внешней переменной extern char  **environ, установленной хост-средой при запуске (см. IEEE Std 1003.1-2017).
При запуске дочернего процесса ему передается сокращенное окружение, включающее набор переменных, указанных в файле, который передается родительскому
процессу как параметр командной строки. Минимальный набор переменных должен
включать SHELL, HOSTNAME, LOGNAME, HOME, LANG, TERM, USER, LC_COLLATE, PATH.
Дочерний процесс открывает этот файл, считывает имена переменных, получает из
окружения их значение и выводит в stdout.
Дочерний процесс (программа child) выводит свое имя, pid, ppid, открывает файл
с набором переменных, считывает их имена, получает из окружения, переданного ему
при запуске, их значение способом, указанным при обработке нажатий, выводит в
stdout и завершается.
Символ «&» завершает выполнение родительского процесса.

Л.р. 4: Взаимодействие и синхронизация процессов
Задание: Действия родительского процесса:
По нажатию клавиши «+» pодительский процесс (P) порождает дочерний процесс
(C_k) и сообщает об этом.
По нажатию клавиши «-» P удаляет последний порожденный C_k, сообщает об
этом и о количестве оставшихся.
При вводе символа «k» P удаляет все C_k и сообщает об этом.
При вводе символа «s» P запрещает всем C_k выводить статистику (см. ниже).
При вводе символа «g» P разрешает всем C_k выводить статистику.
При вводе символов «s<num>» P запрещает C_<num> выводить статистику.
При вводе символов «g<num>» P разрешает C_<num> выводить статистику.
При вводе символов «p<num>» P запрещает всем C_k вывод и запрашивает
C_<num> вывести свою статистику. По истечению заданного времени (5 с, например),
если не введен символ «g», разрешает всем C_k снова выводить статистику.
По нажатию клавиши «q» P удаляет все C_k, сообщает об этом и завершается.
Действия дочернего процесса:
Дочерний процесс во внешнем цикле заводит будильник (nanosleep(2)) и входит в
вечный цикл, в котором в режиме чередования заполняет структуру, содержащую пару
переменных типа int, значениями {0, 0} и {1, 1} (см. раздел «Проблемы неатомарного
доступа» темы «Сигналы»).
При получении сигнала от будильника проверяет содержимое структуры, собирает
статистику и повторяет тело внешнего цикла.
Через заданное количество повторений внешнего цикла (например, через 101)
дочерний процесс, если ему разрешено, выводит свои PPID, PID и 4 числа — количество
разных пар, зарегистрированных в момент получения сигнала от будильника.
Вывод осуществляется посимвольно.
C_k запрашивает доступ к stdout у P и осуществляет вывод после подтверждения.
По завершению вывода C_k сообщает P об этом.
Следует подобрать интервал времени ожидания и количество повторений внешнего цикла, чтобы статистика была значимой. 

Л.р. 5: Потоки исполнение (threads).
Задание: Реализовать возможность создания и удаления потоков.

Л.р. 6: Взаимодействие и синхронизация потоков. Посимвольный вывод.
Задание: Организовать посимвольный вывод, синхронизировав работу потоков с помощью мьютекса.

Л.р. 7: Задача производители-потребители для процессов.
Задание: Основной процесс создает очередь сообщений, после чего ожидает и обрабатывает нажатия клавиш, порождая и завершая процессы двух типов: производители и потребители.
Очередь сообщений представляет собой классическую структуру —  буфер. Помимо этого очередь содержит счетчик добавленных сообщений и счетчик извлеченных.
Производители формируют сообщения и, если в очереди есть место, перемещают
их туда, потребители, если в очереди есть сообщения, извлекают их оттуда.
Для работы используются два семафора для заполнения и извлечения, а также
мьютекс или одноместный семафор для монопольного доступа к очереди

Л.р. 8:  Задача производители-потребители для потоков. 
Задание: аналогично седьмой лабораторной работе, только для потоков.

Л.р. 9: Разделяемая память. 
Задание: Создать несколько потоков. Каждый из них может отправлять в память сообщение. Остальные должны его выводить на экран. 

Л.р. 10: Ассинхронный ввод-вывод. 
Задание: Разработать программу, выполняющую ассинхронное считывание трёх текстовых файлов и ассинхронную запись считанного в результирующий файл.

Л.р. 11: Сокеты. Взаимодействие процессов.
Задание: разработать TCP/IP чат. 
